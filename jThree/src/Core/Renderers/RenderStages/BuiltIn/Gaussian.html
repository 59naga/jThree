<?xml version="1.0" encoding="UTF-8"?>
  <rsml>
    <stage name="jthree.basic.gaussian">
      <technique target="quad">
        <fbo>
          <color name="BUF" register="0" />
        </fbo>
        <material name="jthree.basic.gaussian.1" order="300">
          <uniform-register>
            <register name="builtin.buffer" />
            <register name="builtin.basic" />
          </uniform-register>
          <passes>
            <pass>
              <depth enabled="false" />
              <glsl><![CDATA[
            attribute vec3 position;
            varying vec4 vPosition;

            @vertonly{
              uniform mat4 _matV;

              void main(void)
              {
              	vPosition = vec4(position,1.0);
                gl_Position = vec4(position,1.0);
              }
            }

            @fragonly{
              uniform vec2 _resolution;
              uniform float weight[10];
              @{type:"buffer",name:"INPUT",register:0}
              uniform sampler2D _texture;
              void main(void){
                fc = gl_FragCoord.st;
                destColor += texture2D(texture, (fc + vec2(-9.0, 0.0)) * tFrag).rgb * weight[9];
                destColor += texture2D(texture, (fc + vec2(-8.0, 0.0)) * tFrag).rgb * weight[8];
                destColor += texture2D(texture, (fc + vec2(-7.0, 0.0)) * tFrag).rgb * weight[7];
                destColor += texture2D(texture, (fc + vec2(-6.0, 0.0)) * tFrag).rgb * weight[6];
                destColor += texture2D(texture, (fc + vec2(-5.0, 0.0)) * tFrag).rgb * weight[5];
                destColor += texture2D(texture, (fc + vec2(-4.0, 0.0)) * tFrag).rgb * weight[4];
                destColor += texture2D(texture, (fc + vec2(-3.0, 0.0)) * tFrag).rgb * weight[3];
                destColor += texture2D(texture, (fc + vec2(-2.0, 0.0)) * tFrag).rgb * weight[2];
                destColor += texture2D(texture, (fc + vec2(-1.0, 0.0)) * tFrag).rgb * weight[1];
                destColor += texture2D(texture, (fc + vec2( 0.0, 0.0)) * tFrag).rgb * weight[0];
                destColor += texture2D(texture, (fc + vec2( 1.0, 0.0)) * tFrag).rgb * weight[1];
                destColor += texture2D(texture, (fc + vec2( 2.0, 0.0)) * tFrag).rgb * weight[2];
                destColor += texture2D(texture, (fc + vec2( 3.0, 0.0)) * tFrag).rgb * weight[3];
                destColor += texture2D(texture, (fc + vec2( 4.0, 0.0)) * tFrag).rgb * weight[4];
                destColor += texture2D(texture, (fc + vec2( 5.0, 0.0)) * tFrag).rgb * weight[5];
                destColor += texture2D(texture, (fc + vec2( 6.0, 0.0)) * tFrag).rgb * weight[6];
                destColor += texture2D(texture, (fc + vec2( 7.0, 0.0)) * tFrag).rgb * weight[7];
                destColor += texture2D(texture, (fc + vec2( 8.0, 0.0)) * tFrag).rgb * weight[8];
                destColor += texture2D(texture, (fc + vec2( 9.0, 0.0)) * tFrag).rgb * weight[9];
              }
            }
            ]]>
              </glsl>
            </pass>
          </passes>
        </material>
      </technique>
      <technique target="quad">
        <fbo primary="OUT">
          <color name="OUT" register="0" />
        </fbo>
        <material name="jthree.basic.gaussian.2" order="300">
          <uniform-register>
            <register name="builtin.buffer" />
            <register name="builtin.basic" />
          </uniform-register>
          <passes>
            <pass>
              <depth enabled="false" />
              <glsl><![CDATA[
            attribute vec3 position;
            varying vec4 vPosition;

            @vertonly{
              uniform mat4 _matV;

              void main(void)
              {
                vPosition = vec4(position,1.0);
                gl_Position = vec4(position,1.0);
              }
            }

            @fragonly{
              uniform vec2 _resolution;
              uniform float weight[10];
              @{type:"buffer",name:"BUF",register:0}
              uniform sampler2D _texture;
              void main(void){
                vec2 offset[9];
                offset[0] = vec2(-1.0, -1.0);
                offset[1] = vec2( 0.0, -1.0);
                offset[2] = vec2( 1.0, -1.0);
                offset[3] = vec2(-1.0,  0.0);
                offset[4] = vec2( 0.0,  0.0);
                offset[5] = vec2( 1.0,  0.0);
                offset[6] = vec2(-1.0,  1.0);
                offset[7] = vec2( 0.0,  1.0);
                offset[8] = vec2( 1.0,  1.0);
                float tFrag = 1.0 / _resolution.x;
                vec2  fc = vec2(gl_FragCoord.s, gl_FragCoord.t);
                vec3  horizonColor = vec3(0.0);
                vec3  verticalColor = vec3(0.0);
                horizonColor  += texture2D(_texture, (fc + offset[0]) * tFrag).rgb * xKernel[0];
                horizonColor  += texture2D(_texture, (fc + offset[1]) * tFrag).rgb * xKernel[1];
                horizonColor  += texture2D(_texture, (fc + offset[2]) * tFrag).rgb * xKernel[2];
                horizonColor  += texture2D(_texture, (fc + offset[3]) * tFrag).rgb * xKernel[3];
                horizonColor  += texture2D(_texture, (fc + offset[4]) * tFrag).rgb * xKernel[4];
                horizonColor  += texture2D(_texture, (fc + offset[5]) * tFrag).rgb * xKernel[5];
                horizonColor  += texture2D(_texture, (fc + offset[6]) * tFrag).rgb * xKernel[6];
                horizonColor  += texture2D(_texture, (fc + offset[7]) * tFrag).rgb * xKernel[7];
                horizonColor  += texture2D(_texture, (fc + offset[8]) * tFrag).rgb * xKernel[8];

                verticalColor += texture2D(_texture, (fc + offset[0]) * tFrag).rgb * yKernel[0];
                verticalColor += texture2D(_texture, (fc + offset[1]) * tFrag).rgb * yKernel[1];
                verticalColor += texture2D(_texture, (fc + offset[2]) * tFrag).rgb * yKernel[2];
                verticalColor += texture2D(_texture, (fc + offset[3]) * tFrag).rgb * yKernel[3];
                verticalColor += texture2D(_texture, (fc + offset[4]) * tFrag).rgb * yKernel[4];
                verticalColor += texture2D(_texture, (fc + offset[5]) * tFrag).rgb * yKernel[5];
                verticalColor += texture2D(_texture, (fc + offset[6]) * tFrag).rgb * yKernel[6];
                verticalColor += texture2D(_texture, (fc + offset[7]) * tFrag).rgb * yKernel[7];
                verticalColor += texture2D(_texture, (fc + offset[8]) * tFrag).rgb * yKernel[8];

                gl_FragColor = vec4(vec3(sqrt(horizonColor*horizonColor + verticalColor * verticalColor)),1.0);
              }
            }
            ]]>
              </glsl>
            </pass>
          </passes>
        </material>
      </technique>
    </stage>
  </rsml>
